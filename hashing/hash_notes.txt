- Analysis of hashes are based on loading factor.
 - loading factor = n/size -> written as lambda
 - lambda is the number of items in the linked list 



Chaining:
    - h(x) = x % 10 -> this isnt the only function you can use 
    - each element in hash table is a linked list
    - if there is a collision, the linked list will be extended
    - avg succesful search is 1 + lambda/2
    - unsuccessfull search is 1 + lambda

    - Problem: with h(x) = x % 10
        - if all the numbers end in the same digiit, they will be inserted at the same key
        - this would mean that the lamba assertion fails 
        - to choose proper hash function, we need an idea of the keys we are working with

Linear probing:
    - if h(x) = x % 10, then whenever a collision occurs, we move the index by 1 and check again.
    - cyclic, it wraps around if there is a collision at the end
    - loading factor should not be more than 0.5
    - avg successful search is (1/lambda * ln(1/(1-lambda)))
    - avg unsuccessful search is (1/(1-lambda)

    - Downsides:
        - only half of the hash table is used, so space is wasted
        - primary clustering of keys

    - Deleting:
        - if key is found, rehash all the remaining elements
        - deleting is not recommended in linear probing.

Qudratic probing:
    - if h(x) = x % 10, then when collision occurs, we add i^2 to index, where i is 0.1, 1, 2, 3, ...
    - almost exactly the same as linear probing, expect replace i by i^2.

Double hashing:
    - using two hash functions. If collision occurs with one, use the other
    - result of second hash function should not return 0, and should utilize all spaces.
    ex:
        - h(x) = x % 10
        - h2(x) = 7 - (x % 7)
        - h'(x) = (h(x) + i * h2(x))) % 10, where i is 0, 1, 2, 3, ...


Hash function ideas:
    - Mod:
        - loading factor must be <= 0.5. Meaning, half filled.
        - size of hash table should be a prime number, to reduce collisions.
    - Mid-square:
        - example: key = 11. 
            - 11^2 = 121 -> use middle digit as the index
            -  number of middle digits to use is up to you
    - folding:
        - example: key = 123347 
        - take the digits and add
        - 12+33+47 = 92 -> this can be the index or you can add 9+2=11 to use as index
        - for string keys, add the ascii value of each character.
